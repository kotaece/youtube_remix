<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Seek Remix Player</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
        }

        #remix-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none; 
            user-select: none;
        }

        .video-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 56.25vw; 
            min-height: 100vh;
            min-width: 177.78vh; 
            opacity: 0;
            transition: opacity 0.1s linear;
            mix-blend-mode: screen; 
        }

        .video-layer iframe {
            width: 100%;
            height: 100%;
            transform: scale(1.5); /* 広告・UI隠し用の拡大 */
        }
    </style>
</head>
<body>

    <div id="remix-container">
        <div id="player1" class="video-layer"></div>
        <div id="player2" class="video-layer"></div>
        <div id="player3" class="video-layer"></div>
        <div id="player4" class="video-layer"></div>
    </div>

    <script>
        const videoIds = ['aI04_iIGYzs', 'U1tZNUgUZlo', 'tOqDliP-47A', '6kEA8FMht2o'];
        let players = [];
        let playerStates = [false, false, false, false]; // 再生中フラグ

        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        function onYouTubeIframeAPIReady() {
            videoIds.forEach((id, index) => {
                const playerId = 'player' + (index + 1);
                players[index] = new YT.Player(playerId, {
                    videoId: id,
                    playerVars: {
                        'autoplay': 1, 'controls': 0, 'showinfo': 0, 'modestbranding': 1,
                        'mute': 1, 'loop': 1, 'playlist': id, 'playsinline': 1,
                        'rel': 0, 'disablekb': 1, 'iv_load_policy': 3
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': (event) => onPlayerStateChange(event, index)
                    }
                });
            });
        }

        function onPlayerReady(event) {
            event.target.mute();
            event.target.playVideo();
        }

        function onPlayerStateChange(event, index) {
            if (event.data === YT.PlayerState.PLAYING) {
                setTimeout(() => { playerStates[index] = true; }, 1000);
            }
        }

        // 激しい点滅用の透明度変更関数
        function glitchOpacity() {
            const layers = document.querySelectorAll('.video-layer');
            
            layers.forEach((layer, index) => {
                // 再生中のみ処理
                if(playerStates[index]) {
                    
                    // 【激しさのポイント1】
                    // 0.0〜0.8の滑らかな数値ではなく、
                    // 「表示(0.8)」か「非表示(0)」かの2択にする確率を混ぜる
                    // Math.random() > 0.5 で50%の確率でオン・オフ
                    const isFlash = Math.random() > 0.5;
                    
                    if (isFlash) {
                        // オンにする時もランダム性を持たせる
                        layer.style.opacity = Math.random() * 0.9;
                    } else {
                        // オフ（完全に透明）
                        layer.style.opacity = 0;
                    }

                } else {
                    layer.style.opacity = 0;
                }
            });
        }

        function chaoticLoop() {
        // 透明度変更を実行
        glitchOpacity();

        // 次の変更までの時間をランダムに決める
        // 50ms(超高速) 〜 800ms(少しゆったり) の間で毎回変わる
        const nextTime = Math.random() * 750 + 50; 

        // 決まった時間後にまた自分自身を呼ぶ
        setTimeout(chaoticLoop, nextTime);
    }

    // 実行開始（setIntervalの代わりにこれを呼ぶ）
    setTimeout(chaoticLoop, 3000);

    </script>
</body>
</html>